# 作用域和作用域链
当进入一个执行上下文时，执行上下文也会关联一个作用域链（Scope Chain）
+ `作用域链是一个对象列表`，用于变量标识符的求值
+ 当进入一个执行上下时，这个`作用域链被创建、并且根据代码类型，添加一系列的对象`

当我们进入一个执行上下文时，作用域链就会被创建，并且会添加到当前准备执行的执行上下文中。

变量的查找顺序: 会优先去查找VO对象（当前作用域中查找），之后再按照作用域链上的顺序，按顺序查找变量。

作用域链: 作用域链跟定义位置有关系，跟调用位置没有关系。


# 全局代码查找变量
当代码执行时遇到了变量，那么就需要去查找这个变量，优先会先去VO对象中查找变量，查找不到就会去作用域链上去查找，而全局代码的作用域链上只有一个对象GO。


# 函数代码查找变量
当执行函数的时候遇到变量，会优先去自己的VO对象中去查找这个变量，查找不到就会去作用域链上去查找，而函数的作用域链在函数定义的时候就已经被创建了。


# 个人理解
+ 全局代码的作用域链: 作用域列表中只有一个对象`GO`，所以在查找变量的时候只会在GO对象中查找，如果查找不到的话就会报 undefind。
+ 函数代码的作用域链: 函数代码的作用域链在函数声明的时候就已经被确定了，自身 => 上层作用域... => 全局作用域（GO），函数在声明的时候就已经确认了当前的作用域链，它是一个类似数组的对象，之后会把这个类数组对象给函数中的一个叫`[[Scopes]]`属性，当一个函数执行时，会创建一个执行上下文，执行上下文创建的时候会绑定`VO和Scope Chain`，而VO就会是创建的AO对象，而之前确认的作用域链也就是函数中的`[[Scopes]]`中的值作为当前执行上下文中的`Scope Chain`属性的值，当变量查找的时候就会根据当前的作用域链进行查找。所以才会一直从当前作用域一直找到GO对象，如果GO对象中也没有的话就会报 undefind。

  
  