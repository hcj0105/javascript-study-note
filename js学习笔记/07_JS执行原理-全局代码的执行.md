# JS的执行原理

JS引擎会在`执行代码之前`，会在`堆内存中创建一个全局对象`: Global Object（GO）

+ 该对象`所有作用域（scope）` 都可以访问
+ 里面会包含Date、Array、String、Number、setTimeout、setInterval等等属性；
+ 其中还有一个`window属性`指向自己

在JS引擎执行代码之前，会在堆内存中初始化一个对象`Global Object（GO）`，在浏览器中这个`全局对象`就是指`window`，该对象在所有`作用域（scope）`中都可以被访问到，因为所有作用域的查找都会一层一层的向上查找，最终都会查找到全局对象，在这个全局对象初始化的时候会将`Date、Array、String、Number、setTimeout、setInterval`等等属性添加到这个对象中，还包含一些主机中定义的属性（比如，代码执行在node环境中的一些变量，也会添加到这个对象中），其中还有一个window属性指向自己（这个对象）。

# 执行上下文(Execution Contexts)
js引擎内部有一个`执行上下文栈(Execution Contexts Stack，简称ECS)`，它用于执行`代码的调用栈`。

那么现在它要执行谁呢？执行的是`全局的代码块`：
+ 全局的代码块为了执行会构建一个`Global Execution Context(GEC)`（在每个代码块执行前都会创建一个执行上下文来执行代码块）
+ GEC会`被放入到ECS中`执行

GEC被放入到ECS中，GEC中里面包含两部分内容: 
+ 第一部分: 在`parser转成AST的过程`中，会将`全局定义的变量、函数`等加入到`GlobalObject`中，但是并`不会赋值`；这个过程也称之为`变量的作用域提升（hoisting）`
  
  js引擎在翻译我们所有的代码之前会对对应的代码作用域做一些提升，会根据解析代码是生成的标识符，放到一个`Variable Object(VO对象)`


+ 第二部分：在代码执行中，对变量赋值，或者执行其他的函数；
  
  当要执行的代码块时，这块代码会被翻译成`ECMAScript exccutable code（可执行代码前）` ，代码会进入到一个执行上下文中，而这个执行上下文会被放到执行上下文栈中（意思是说，代码要执行需要先进入到执行上下文中）。多个活跃的执行上下文会形成一个栈结构，而最上面的执行上下文永远是正在被执行的执行上下文。


# 认识VO对象(Variable Object)
## 每一个执行上下文会关联一个`VO（Variable Object，变量对象），变量和函数声明`会被添加到这个VO对象中。

在每个执行上下文执行时都会进行翻译，在翻译的过程中会根据解析时生成的标识符（变量），会将这些变量作为属性添加到某个位置中，这个位置就叫`Variable Object（VO对象）`，如果是一个函数，函数也会被放到这个对象当中，相对的函数对象也会被创建，这个函数就指向这个指针，并且函数中的参数也会被添加到这个对象当中。

注: 函数会比变量先声明。

## 当全局代码被执行的时候，VO就是GO对象了。
全局上下文中会有三个东西: `1、作用域链 2、VO对象 3、This`

+ 会创建一个作用域链
+ 变量的实例化时Global Object会作为Variable Object对象
+ 这里的`This`指向这个Global Object


# 全局代码执行过程（执行前）
![全局代码执行前](./image/%E5%85%A8%E5%B1%80%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%89%8D.png)

执行代码执行前js引擎会帮我们创建一个对象而全局代码的这个对象就叫做`全局对象(Global Object（GO）)`，之后执行全局代码，但是在js中每段代码的执行都会创建一个执行上下文，并且压入到`上下文执行栈`中而全局代码创建的执行上下文叫做`全局执行上下文(GEC)`，每个执行上文都会关联一个`VO对象(Variable Object)`，在执行上下文创建的时候会把`声明的变量、函数`作为属性添加到这个对象中进行初始化，但并不会赋值，这个过程也叫做`变量的作用域提升`，而全局代码的这个`VO对象`指的就是`GO对象`。

# 全局代码执行过程（执行后）
![全局代码执行后](./image/%E5%85%A8%E5%B1%80%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%90%8E.png)

将值赋值给对应的变量
