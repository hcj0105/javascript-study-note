<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script src="./utils/自动柯里化函数.js"></script>
    <script src="./utils/自动化组合函数.js"></script>
    <script src="./utils/寄生组合函数.js"></script>
    <script src="./utils/apply、call、bind.js"></script>
    <script>
      // // Set需要使用构造函数的方式定义变量
      // // Set保存的数据不会重复，可以保存任何值。可以用于数组去重。
      // // Set对象是一个可迭代对象。
      // const set = new Set();
      // // 1. Set的属性
      // // 1.1 Size属性：获取当前存储的个数，它是一个属性不是方法
      // console.log(set.size);

      // // 2. Set的方法
      // // 2.1 add方法：用于给set对象添加值
      // const arr = ["添加一个数组"];
      // const info = { name: "添加一个对象" };
      // set.add("添加第一个值");
      // set.add(arr);
      // set.add(info);
      // console.log(set);

      // // 2.2 delete方法：用于删除set对象中的值
      // set.delete(arr);
      // console.log(set);

      // // 2.3 has方法：用于判断值是否存在当前set对象当中
      // console.log(set.has(info));

      // // 2.4 clear方法: 用于清空set对象中所有值
      // set.clear();
      // console.log(set);

      // // 2.5 foreach方法：可以通过foreach方法今天遍历
      // set.forEach((item) => console.log(item));

      // // 3. Set对象可以通过for...of今天迭代
      // for (const item of set) {
      //   console.log(item);
      // }

      // // 4. 使用Set去重方法
      // let reArr = ["abc", "abc", "xxx", "bbb", "xxx"];
      // // 4.1 不是用Set去重
      // const newReArr = [];
      // for (const item of reArr) {
      //   const isHas = newReArr.includes(item);
      //   if (!isHas) newReArr.push(item);
      // }
      // console.log(newReArr);

      // // 4.2 使用Set去重方式一: 因为Set是可迭代对象使用 Array.from 转成数组
      // reArr = Array.from(new Set(reArr));
      // console.log(reArr);

      // // 4.3 使用Set去重方式二:
      // reArr = [...new Set(reArr)];
      // console.log(reArr);

      // WeakSet 与 Set 区别
      // 1. WeakSet只能存储引用类型不能存储值类型， Set都可以存储
      // 2. WeakSet是弱引用，Set是强引用
      // 3. WeakSet 和 Set 同样存储的值不能重复

      // // WeakSet
      // const wSet = new WeakSet();
      // // 1. WeakSet的方法
      // // 1.1 add方法
      // // wSet.add('我是值类型') // Invalid value used in weak set
      // const obj2 = { name: "obj2" };
      // const obj3 = { name: "obj3" };
      // wSet.add(obj2);
      // wSet.add(obj3);
      // console.log(wSet);

      // // 1.2 delete方法
      // wSet.delete(obj2)
      // console.log(wSet);

      // // 1.3 has方法
      // console.log(wSet.has(obj2));

      // // 2. WeakSet的值是无法获取的，因为WeakSet是弱引用，如果获取了值，那么存储的值就会被其他变量引用，导致GC回收的时候无法销毁。
      // for (const item of wSet) {
      //   console.log(item) // wSet is not iterable
      // }

      // Map 和 Object 区别
      // Map可以使用任意类型值作为key，Object只能使用字符串类型和Symbol类型作为key，如果使用其他类型作为key会被转换为字符串类型。

      // Map用于存储映射关系
      // Map可以使用任意类型的值作为key
      // const map = new Map();

      // // 1. Map的属性
      // // 1.1 size属性：用于获取Map中元素的个数
      // console.log(map.size);

      // // 2. Map的方法
      // // 2.1 set方法：添加元素到Map元素中 (key: any, value: any)
      // const info = { name: "我是info" };
      // const obj = { name: "我是obj" };
      // map.set("key", "value");
      // map.set(info, "aaa");
      // map.set(obj, "bbb");
      // console.log(map);

      // // 2.2 get方法：通过key来获取Map中的元素
      // console.log(map.get(info)); // aaa

      // // 2.3 delete方法: 通过key来删除Map中的元素
      // map.delete("key");
      // console.log(map);

      // // 2.4 has方法: 通过key来判断，当前元素是否存在在Map中
      // console.log(map.has("key")); // false

      // // 2.5 clear方法: 用于清空Map
      // map.clear()
      // console.log(map);

      // // 2.6 foreach方法：可以通过foreach方法进行遍历
      // map.forEach((item) => console.log(item));
      // console.log(map);

      // // 3. Set对象可以通过for...of今天迭代
      // for (const item of map) {
      //   console.log(item);
      // }

      // WeakMap 和 Map 区别
      // 1. WeakMap只能使用对象作为key，Map可以使用任意类型作为key
      // 2. WeakMap是弱引用， Map是强引用
      // 3. WeakSet不能迭代，Map可以迭代

      // const wMap = new WeakMap()
      // // 1. WeakMap的方法
      // // 1.1 set方法：添加元素到WeakMap元素中 (key: any, value: any)
      // const info = { name: "我是info" };
      // const obj = { name: "我是obj" };
      // // wMap.set("key", "value"); // Invalid value used as weak map key
      // wMap.set(info, "aaa");
      // wMap.set(obj, "bbb");
      // console.log(wMap);

      // // 1.2 get方法：通过key来获取WeakMap中的元素
      // console.log(wMap.get(info)); // aaa

      // // 1.3 delete方法: 通过key来删除WeakMap中的元素
      // wMap.delete("key");
      // console.log(wMap);

      // // 1.4 has方法: 通过key来判断，当前元素是否存在在WeakMap中
      // console.log(wMap.has("key")); // false

      // let obj1 = { name: "obj1" }; // 强引用
      // let obj2 = { name: "obj2" }; // 强引用
      // let obj3 = { name: "obj3" }; // 强引用

      // const arr = new WeakSet(); // arr对当前的WeakSet是强引用，里面的元素是弱引用

      // arr.add(obj1);
      // arr.add(obj2);
      // arr.add(obj3);

      // obj1 = null;
      // obj2 = null;
      // obj3 = null;

      // 当GC回收的时候发现没有变量引用着这三个对象，那么这个三个对象会被销毁。但是可以获取到值。（弱引用）
      // 当GC回收的时候发现没有变量引用着这三个对象，那么这个三个对象不会被销毁。（强引用）

      class Person {
        running() {
          console.log(this);
        }
      }
    </script>
  </body>
</html>
