# 认识内存管理
不管什么样的变成语言，在代码执行的过程中都需要给它分配内存，不同的是某些变成语言需要我们自己手动的管理内存，某些变成语言会自动帮我们管理内存。

不管以什么样的方式来管理内存，内存的管理都会有如下的生命周期：
+ 第一步：分配申请你需要的内存(申请)
+ 第二步: 使用分配的内存(存方一些东西，比如对象等)
+ 第三步: 不需要使用时，对其经行释放

争对不同的编程语言对于第一步和第三步会有不同的实现: 
+ 手动管理内存: C、C++ 
+ 自动管理内存: JS、Java、Python、Dart、Swift

# JavaScript的内存管理

JavaScript会在定义数据时为我们分配内存。但是内存分配的方式不一样： 
+ 对于原始数据类型的内存分配：JS会在执行的时候直接在栈空间进行分配，并且在VO中也保存一份
+ 对于复杂数据类型的内存分配（对象）: JS会在执行的时候直接在堆内存中开辟一块空间，并且将这块空间的指针（内存地址）给这个变量引用。

# 常见的GC算法

## 引用计数（Reference Counting）: 
+ 当`一个对象有一个引用指向它`时，那么这个`对象的引用就+1`
+ 当一个`对象的引用为0`时，这个对象就可以被销毁掉；

  比如说，当你创建了一个对象，这个对象中会有一个属性`retainCount`来记录自己被引用的次数，被引用一次就会+1，当某个变量或者属性不引用了就会-1，当这个属性为0的时候就说明这个对象没有被引用了已经没有用了，就会被销毁掉（当作垃圾回收掉）。
  
  这个算法有一个很大的弊端就是会产生循环引用，比如：
  ```JavaScript
  var obj1 = {} 
  var obj2 = {}

  obj1.info = obj2 // info 引用 obj2
  obj2.info = obj1 // info 引用 obj1

  obj1 = null
  obj2 = null
  ```
  原本obj1、obj2都引用的两个对象的内存地址，之后obj1.info、obj2.info也分别引用obj1和obj2，那么这两个对象在内存中分别都有两次记录记记录着有两个变量引用着自己，之后把obj1、obj2都指向了空地址取消了对内存地址的引用，但是在内存中也只是取消一次记录的引用，可是obj1.info指向的是obj2的内存地址、obj2.info指向的是obj1的内存地址，在内存中的表现就是相互引用着对方，就造成了循环引用，这两个内存就永远不会被销毁掉。解决办法就是把obj1.info或者obj2.info其中一个指向空地址让引用取消。

## 标记清除（mark-Sweep）：
+ 标记清除的核心思路是`可达性(Reachability)`
+ 这个算法是设置一个`根对象（root object），垃圾回收器`会定期`从这个根开始`，找所有从根开始`有引用到的对象`，对于那些`没有引用到的对象，就认为是不可用的对象`。

   这个可达性的算法很好的解决了循环引用的问题，就拿上面引用计数产生的循环引用为例子，可达性算法会定义一个根对象，之后从这个根对象上一直去查找有引用的对象进行标记，前面的例子中，当我们把obj1、obj2的指向指到了空，那么对于可达性算法来说从根对象去查找，发现obj1.info、obj2.info没有引用到，那么就会被当作没有引用垃圾回收器在下次清理的时候就会把这两个对象给销毁掉。

# 常见的GC算法-其他算法优化补充
JS引擎比较广泛的采用的就是可达性中的标记清除算法，当然类似于V8引擎为了进行更好的优化，它在算法的实现细节上也会
结合一些其他的算法

## 标记整理（Mark-Compact）和 "标记 - 清除" 相似
+ 不同的是，回收期间同时会将保留的对象`搬运汇集到连续的内存空间`，从而`整合空闲空间，避免内存碎片化`。

  比如说：一段连续的内存，但是通过垃圾回收之后中间可能有一两个内存空间被销毁了就会腾出空间来这样内存就会不连续产生碎片化的内存空间，但是这些内存占据的空间比较小，如果出现了比较大一点的内存就放不进去，那么这些内存空间就只能等差不多的内存被开辟的时候放入，这样就会很浪费内存空间，而标记整理算法做的就是把这些不连续的碎片化的内存整理一个变成连续的内存，这样大一些的内存就可以放进去，内存就不会被浪费掉。

## 分代收集（Generational Collection）-- 对象被分成两组：`"新的"和"旧的"`
+ 许多对象出现，完成他们的工作并很快死去，它们可以很快被清理
+ 那些长期存活的对象会变得`"老旧"`，而且`被检查的频次也会减少`
  
   可达性算法在做标记清除的时候也是很消耗性能的，所以V8引擎对其做了优化，V8引擎在堆内存中划分了两个区域`新的和旧的`两个空间，新创建的内存会被分配到`新的区域`，而`新的区域`又有两个空间一个叫`from space`一个`to space`，新创建的内存会先被放到`from space`中，之后当GC过来清理把没有用的内存销毁后，会把剩下的内存放到`to space`，这个时候`to space`和`from space`就会进行互换，`to space`就会变成`from space`，`from space`变成`to space`，当有新创建的内存就会被分配到`from space`中，等到下次GC来进行清理的时候，经过两轮的清理，发现还剩下的的内存，V8引擎就会把这些内存放到`旧的区域`，如此循环。 这就是分代收集。

## 增量收集（Incremental Collection）
+ 如果有许多对象，并且我们`试图一次便利并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟`
+ 所以引擎试图`将垃圾收集工作分成几部分来做`，然后`将这几部分会逐一进行处理，这样会有许多微笑的延迟而不是一个大的延迟`

## 闲时收集（idle-time-collection）
+ 垃圾收集器`指挥在CPU空闲时尝试运行，以减少可能对代码执行`的影响
  
![v8引擎详细内存图](./image/v8%E5%BC%95%E6%93%8E%E5%86%85%E5%AD%98%E5%9B%BE.png)


# 小知识
+ 垃圾回收的概念最早出现在的语言是`Lisp`
